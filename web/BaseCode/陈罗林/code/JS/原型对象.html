<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
 
        function Phone(brand,price){
            this.brand = brand;
            this.price = price;
            // this.call = function(){
            //     alert(this.brand+"打电话...");
            // }
        }

        //改进  向Phone的原型中添加call方法
        Phone.prototype.call = function(){
            alert(this.brand+"打电话...");
        };


        var phone1 = new Phone("苹果",8999);
        var phone2 = new Phone("华为",7999);
        phone1.call();
        /*
        原型对象prototype
            -我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
             这个属性对应着一个对象，这个对象就是原型对象
        */
        function MyClass(){

        }
        var mc1 = new MyClass();
        var mc2 = new MyClass();
        console.log(MyClass.prototype);
        /*        
            -如果函数作为普通函数调用prototype没有任何用
             当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，
             指向该构造函数的原型对象，我们可以通过__proto__来访问该属性
        */
        console.log(mc1.__proto__ == MyClass.prototype);
        /*
            -原型对象就相当于一个公共的区域，所有同一类的实例都可以访问到这个原型对象，
             我们可以将对象中共有的内容，统一设置到原型对象中
        */
        /*
            -当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有直接用，没有则会去原型对象中寻找
        */
        MyClass.prototype.a = 123;
        console.log(mc1.a);

        //使用对象的hasOwnProperty()来检查对象自身中是否含有某属性
        console.log(phone1.hasOwnProperty("brand"));

        /*
        重写toString方法
        */
        Phone.prototype.toString = function(){
            return "Phone[brand="+this.brand+",price="+this.price+"]";
        };
        var phone3 = new Phone("小米",6999);
        console.log(phone3.toString());
        
    </script>
</head>
<body>
    
</body>
</html>