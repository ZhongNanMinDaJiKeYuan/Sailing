1.公共规范标准，只要符合标准大家都可以使用，java中的接口更多的体现在对行为的抽象
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
2.接口用interface修饰，
**   public class demo0{}
**  public interface Jumpping{} //定义了一个接口
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
3.
类实现一个接口，类似于类继承抽象类，同样需要方法重写，但extends改为implements
**public class Cat implements Jumpping{
      @Override
      public void jump() {
          System.out.println("cat jump");
      }
  }
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
4.因为接口是抽象的内容，故不可以直接实例化
**因此接口的示例化也是通过多态来实现实例化
**Jumpping jp = new Cat();
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
5.接口的成员特点
**对成员变量
public int num = 10；等同于下列
public static final int num = 10;
**即数据成员默认被 public static final 修饰
(解释：接口为公共规范标准，只要符合标准大家都可以使用，同时标准不可更改。所以所有对象为static静态修饰（可以被接口名直接访问）且被final修饰为常量)

**对构造方法
接口没有构造方法，但是如何在接口的实现类中实现：
public InterImpl() {
    super();    //调用接口中的构造方法？如何实现？
}

**Class Object,类Object是类层次的根，是每一个类的超类，即每个类都间接或直接继承了Object类
Object类只有无参构造方法
即默认有：
public class InterImpl extends Object implements Inter{}

**接口内只能有抽象的成员方法
接口内方法默认带 public abstract修饰
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
6.
*类与接口的关系
**实现关系可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
例：public class InterImpl extends Object implement Inter1,Inter2,Inter3 {}

*接口与接口的关系
**可以多继承也可以单继承
例： public class Inter1 extends Inter2,Inter3
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
7.
*抽象类和接口的区别
使用：对象一定能做到的写在抽象类中，不一定的写在接口中
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
8.
*形参与返回值
**类名作为形参与返回值(其实需要的与返回的都是该类的对象)
例：
public void useEat(Car c) { //Cat c = new Cat();
        c.eat();
}
其中形参为对象，在使用该方法时，需要创建相应对象

例：
public Cat getCat() {
    Cat c = new Cat();
    return c;
}

Cat c2 = c0.getCat(); //new Cat()

**抽象类作为形参与返回值(使用多态创建子类对象再作为形参，返回的也是多态的对象)

**接口名作为形参与返回值(该接口的实现类对象，返回的是该接口的实现类对象)
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
9.内部类
*在一个类的内部再定义一个类
public class 类名 {
    修饰符 class 类名{}
}

*内部类可以直接访问外部类的成员，包括私有
*外部内想要访问内部类的成员，必须创建对象，用对象去访问

*在类的成员位置：成员内部类
**成员内部类的创建对象
外部类名.内部类名 对象名 = 外部对象.内部对象;
Outer.Inner oi = new Outer().new Inner(); // 不针对私有

对private修饰的成员内部类：
定义方法(即通过外部类对象调用方法使用内部类的方法)
public void method() {
    Inner i = new Inner();
}

*在类的局部位置：局部内部类(可以直接访问外部类成员，也可以访问方法内的局部变量)
在类的方法里面定义一个类
public class Outer{
    private int num = 10;

    public void method() {
        class Inner{
            ...
        }
        Inner i = new Inner();
    }
}

*匿名内部类(需要在方法中定义)
**前提：存在一个类或接口，这里的类可以是具体类或抽象类
**本质：是一个继承了该类或者实现了该接口的子类匿名对象
**格式：
new 类名或接口名() {
    @Override
    public void show() {
        System.out.println("......")
    }
}；是一个对象

new Inner() {
    @Override
        public void show() {
            System.out.println("......")
        }
}.show(); //用这种方式来调用

**如果是多次调用
Inner i = new Inner() {
    @Override
            public void show() {
                System.out.println("......")
            }
};
i.show();

**总结:匿名内部类直接代替实现类，匿名内部类重写了方法，相当于实现类，但它没名字。